1. Standard Binary Search
cpp
Copy code
#include <vector>
#include <iostream>

int binarySearch(const std::vector<int>& arr, int target) {
    int left = 0, right = arr.size() - 1;
    
    while (left <= right) {
        int mid = left + (right - left) / 2;
        
        if (arr[mid] == target) {
            return mid;
        } else if (arr[mid] < target) {
            left = mid + 1;
        } else {
            right = mid - 1;
        }
    }
    
    return -1;  // Target not found
}

int main() {
    std::vector<int> arr = {1, 2, 3, 4, 5, 6, 7};
    int target = 5;
    int result = binarySearch(arr, target);
    std::cout << "Index of target: " << result << std::endl;  // Output should be 4
    return 0;
}
2. First or Last Occurrence
First Occurrence
cpp
Copy code
int findFirstOccurrence(const std::vector<int>& arr, int target) {
    int left = 0, right = arr.size() - 1;
    int result = -1;
    
    while (left <= right) {
        int mid = left + (right - left) / 2;
        
        if (arr[mid] == target) {
            result = mid;
            right = mid - 1;  // Look on the left side
        } else if (arr[mid] < target) {
            left = mid + 1;
        } else {
            right = mid - 1;
        }
    }
    
    return result;
}
Last Occurrence
cpp
Copy code
int findLastOccurrence(const std::vector<int>& arr, int target) {
    int left = 0, right = arr.size() - 1;
    int result = -1;
    
    while (left <= right) {
        int mid = left + (right - left) / 2;
        
        if (arr[mid] == target) {
            result = mid;
            left = mid + 1;  // Look on the right side
        } else if (arr[mid] < target) {
            left = mid + 1;
        } else {
            right = mid - 1;
        }
    }
    
    return result;
}
3. Rotated Sorted Array
cpp
Copy code
int searchRotatedArray(const std::vector<int>& arr, int target) {
    int left = 0, right = arr.size() - 1;
    
    while (left <= right) {
        int mid = left + (right - left) / 2;
        
        if (arr[mid] == target) {
            return mid;
        }
        
        if (arr[left] <= arr[mid]) {
            if (arr[left] <= target && target < arr[mid]) {
                right = mid - 1;
            } else {
                left = mid + 1;
            }
        } else {
            if (arr[mid] < target && target <= arr[right]) {
                left = mid + 1;
            } else {
                right = mid - 1;
            }
        }
    }
    
    return -1;
}
4. Search Insert Position
cpp
Copy code
int searchInsertPosition(const std::vector<int>& arr, int target) {
    int left = 0, right = arr.size() - 1;
    
    while (left <= right) {
        int mid = left + (right - left) / 2;
        
        if (arr[mid] == target) {
            return mid;
        } else if (arr[mid] < target) {
            left = mid + 1;
        } else {
            right = mid - 1;
        }
    }
    
    return left;  // Position where target should be inserted
}
5. Finding Minimum in Rotated Sorted Array
cpp
Copy code
int findMinInRotatedArray(const std::vector<int>& arr) {
    int left = 0, right = arr.size() - 1;
    
    while (left < right) {
        int mid = left + (right - left) / 2;
        
        if (arr[mid] > arr[right]) {
            left = mid + 1;
        } else {
            right = mid;
        }
    }
    
    return arr[left];
}
Example Usage
Here's how you can use these functions in a main function:

cpp
Copy code
int main() {
    // Example for standard binary search
    std::vector<int> arr = {1, 2, 3, 4, 5, 6, 7};
    int target = 5;
    std::cout << "Binary Search Index: " << binarySearch(arr, target) << std::endl;
    
    // Example for first occurrence
    std::vector<int> arrWithDuplicates = {1, 2, 2, 2, 3, 4};
    std::cout << "First Occurrence Index: " << findFirstOccurrence(arrWithDuplicates, 2) << std::endl;
    
    // Example for rotated sorted array search
    std::vector<int> rotatedArr = {4, 5, 6, 7, 0, 1, 2};
    std::cout << "Rotated Array Search Index: " << searchRotatedArray(rotatedArr, 0) << std::endl;
    
    // Example for search insert position
    std::vector<int> insertArr = {1, 3, 5, 6};
    std::cout << "Search Insert Position: " << searchInsertPosition(insertArr, 5) << std::endl;
    
    // Example for finding minimum in rotated sorted array
    std::vector<int> rotatedArrForMin = {4, 5, 6, 7, 0, 1, 2};
    std::cout << "Minimum in Rotated Array: " << findMinInRotatedArray(rotatedArrForMin) << std::endl;

    return 0;
}
This covers some common binary search problems in C++. If you have any specific questions or another type of binary search problem in mind, feel free to ask!








----------------------------------------------------------sort


1. Bubble Sort
Bubble sort repeatedly steps through the list, compares adjacent elements, and swaps them if they are in the wrong order. This process is repeated until the list is sorted.

Example:

cpp
Copy code
#include <vector>
#include <iostream>

void bubbleSort(std::vector<int>& arr) {
    int n = arr.size();
    for (int i = 0; i < n - 1; ++i) {
        for (int j = 0; j < n - i - 1; ++j) {
            if (arr[j] > arr[j + 1]) {
                std::swap(arr[j], arr[j + 1]);
            }
        }
    }
}

int main() {
    std::vector<int> arr = {64, 34, 25, 12, 22, 11, 90};
    bubbleSort(arr);
    for (int num : arr) {
        std::cout << num << " ";
    }
    return 0;
}
2. Selection Sort
Selection sort divides the input list into two parts: the sublist of items already sorted and the sublist of items remaining to be sorted. It repeatedly selects the smallest (or largest) element from the unsorted sublist and swaps it with the leftmost unsorted element.

Example:

cpp
Copy code
#include <vector>
#include <iostream>

void selectionSort(std::vector<int>& arr) {
    int n = arr.size();
    for (int i = 0; i < n - 1; ++i) {
        int minIndex = i;
        for (int j = i + 1; j < n; ++j) {
            if (arr[j] < arr[minIndex]) {
                minIndex = j;
            }
        }
        std::swap(arr[i], arr[minIndex]);
    }
}

int main() {
    std::vector<int> arr = {64, 25, 12, 22, 11};
    selectionSort(arr);
    for (int num : arr) {
        std::cout << num << " ";
    }
    return 0;
}
3. Insertion Sort
Insertion sort builds the final sorted array one item at a time. It is much less efficient on large lists than more advanced algorithms such as quicksort, heapsort, or merge sort.

Example:

cpp
Copy code
#include <vector>
#include <iostream>

void insertionSort(std::vector<int>& arr) {
    int n = arr.size();
    for (int i = 1; i < n; ++i) {
        int key = arr[i];
        int j = i - 1;
        while (j >= 0 && arr[j] > key) {
            arr[j + 1] = arr[j];
            --j;
        }
        arr[j + 1] = key;
    }
}

int main() {
    std::vector<int> arr = {12, 11, 13, 5, 6};
    insertionSort(arr);
    for (int num : arr) {
        std::cout << num << " ";
    }
    return 0;
}
4. Merge Sort
Merge sort is a divide and conquer algorithm that was invented by John von Neumann in 1945. It divides the input array into two halves, calls itself for the two halves, and then merges the two sorted halves.

Example:

cpp
Copy code
#include <vector>
#include <iostream>

void merge(std::vector<int>& arr, int left, int mid, int right) {
    int n1 = mid - left + 1;
    int n2 = right - mid;
    
    std::vector<int> L(n1), R(n2);
    
    for (int i = 0; i < n1; ++i)
        L[i] = arr[left + i];
    for (int j = 0; j < n2; ++j)
        R[j] = arr[mid + 1 + j];
    
    int i = 0, j = 0, k = left;
    while (i < n1 && j < n2) {
        if (L[i] <= R[j]) {
            arr[k++] = L[i++];
        } else {
            arr[k++] = R[j++];
        }
    }
    
    while (i < n1) {
        arr[k++] = L[i++];
    }
    
    while (j < n2) {
        arr[k++] = R[j++];
    }
}

void mergeSort(std::vector<int>& arr, int left, int right) {
    if (left < right) {
        int mid = left + (right - left) / 2;
        mergeSort(arr, left, mid);
        mergeSort(arr, mid + 1, right);
        merge(arr, left, mid, right);
    }
}

int main() {
    std::vector<int> arr = {12, 11, 13, 5, 6, 7};
    mergeSort(arr, 0, arr.size() - 1);
    for (int num : arr) {
        std::cout << num << " ";
    }
    return 0;
}
5. Quick Sort
Quick sort is a highly efficient sorting algorithm and is based on partitioning an array into smaller sub-arrays. Developed by Tony Hoare in 1959, it works by selecting a 'pivot' element and partitioning the other elements into two sub-arrays, according to whether they are less than or greater than the pivot.

Example:

cpp
Copy code
#include <vector>
#include <iostream>

int partition(std::vector<int>& arr, int low, int high) {
    int pivot = arr[high];
    int i = low - 1;
    
    for (int j = low; j < high; ++j) {
        if (arr[j] <= pivot) {
            ++i;
            std::swap(arr[i], arr[j]);
        }
    }
    std::swap(arr[i + 1], arr[high]);
    return i + 1;
}

void quickSort(std::vector<int>& arr, int low, int high) {
    if (low < high) {
        int pi = partition(arr, low, high);
        quickSort(arr, low, pi - 1);
        quickSort(arr, pi + 1, high);
    }
}

int main() {
    std::vector<int> arr = {10, 7, 8, 9, 1, 5};
    quickSort(arr, 0, arr.size() - 1);
    for (int num : arr) {
        std::cout << num << " ";
    }
    return 0;
}
6. Heap Sort
Heap sort is a comparison-based sorting technique based on Binary Heap data structure. It is similar to selection sort where we first find the maximum element and place the maximum element at the end.

Example:

cpp
Copy code
#include <vector>
#include <iostream>

void heapify(std::vector<int>& arr, int n, int i) {
    int largest = i;
    int left = 2 * i + 1;
    int right = 2 * i + 2;
    
    if (left < n && arr[left] > arr[largest]) {
        largest = left;
    }
    
    if (right < n && arr[right] > arr[largest]) {
        largest = right;
    }
    
    if (largest != i) {
        std::swap(arr[i], arr[largest]);
        heapify(arr, n, largest);
    }
}

void heapSort(std::vector<int>& arr) {
    int n = arr.size();
    
    for (int i = n / 2 - 1; i >= 0; --i) {
        heapify(arr, n, i);
    }
    
    for (int i = n - 1; i >= 0; --i) {
        std::swap(arr[0], arr[i]);
        heapify(arr, i, 0);
    }
}

int main() {
    std::vector<int> arr = {12, 11, 13, 5, 6, 7};
    heapSort(arr);
    for (int num : arr) {
        std::cout << num << " ";
    }
    return 0;
}
7. Counting Sort
Counting sort is an integer sorting algorithm. It sorts the elements by counting the number of occurrences of each element. Since it operates by counting the number of objects with distinct key values, it is not a comparison sort and can have a time complexity of 
𝑂
(
𝑛
+
𝑘
)
O(n+k) where 
𝑛
n is the number of elements in the input array and 
𝑘
k is the range of the input.

Example:

cpp
Copy code
#include <vector>
#include <iostream>

void countingSort(std::vector<int>& arr) {
    int maxVal = *max_element(arr.begin(), arr.end());
    int minVal = *min_element(arr.begin(), arr.end());
    int range = maxVal - minVal + 1;
    
    std::vector<int> count(range), output(arr.size());
    
    for (int num : arr) {
        ++count[num - minVal];
    }
    
    for (int i = 1; i < count.size(); ++i) {
        count[i] += count[i - 1];
    }
    